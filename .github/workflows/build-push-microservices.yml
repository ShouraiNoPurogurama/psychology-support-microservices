name: Build & Push Microservices (GHCR)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  # 0) Chọn runner ưu tiên (self-hosted nếu online; fallback ubuntu-latest)
  pick-runner:
    runs-on: ubuntu-latest
    outputs:
      runs_on: ${{ steps.decide.outputs.runs_on }}
    steps:
      - name: 🤖 Decide runner (prefer self-hosted "NA Self Hosted Runner")
        id: decide
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RUNNER_ADMIN_TOKEN }}
          script: |
            core.info('🔎 Checking self-hosted runners…')
            const res = await github.rest.actions.listSelfHostedRunnersForRepo({ owner: context.repo.owner, repo: context.repo.repo, per_page: 100 });
            const runners = res.data.runners ?? [];
            const target = 'na self hosted runner';
            const wanted = runners.find(r => {
              const labels = (r.labels || []).map(l => (l.name || '').toLowerCase());
              const nameLc = (r.name || '').toLowerCase();
              return (labels.includes(target) || nameLc === target) && r.status==='online' && !r.busy;
            });
            if (wanted) {
              const names = (wanted.labels||[]).map(l=>l.name).filter(Boolean);
              if (!names.map(s=>s.toLowerCase()).includes('self-hosted')) names.unshift('self-hosted');
              const preferred = names.includes('windows-prod') ? ['self-hosted','windows-prod'] : names;
              core.info(`✅ Using self-hosted runner: ${wanted.name} [labels: ${(wanted.labels||[]).map(l=>l.name).join(', ')}]`);
              core.setOutput('runs_on', JSON.stringify(preferred));
            } else {
              core.info('ℹ️ No suitable self-hosted runner online → fallback ubuntu-latest');
              core.setOutput('runs_on', JSON.stringify("ubuntu-latest"));
            }

  # 1) Detect services thay đổi (hoặc build all khi dispatch / diff rỗng)
  detect-services:
    runs-on: ubuntu-latest
    needs: pick-runner
    outputs:
      services: ${{ steps.out.outputs.services }}
    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🧮 Compute smart diff & map to services
        id: out
        shell: bash
        env:
          BEFORE: ${{ github.event.before }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail
          echo "🔧 EVENT_NAME=${EVENT_NAME}"
          echo "🔧 BEFORE=${BEFORE:-<empty>}"
          ALL_SERVICES=( "aimoderation.api" "alias.api" "auth.api" "chatbox.api" "digitalgoods.api" "feed.api" "media.api" "payment.api" "post.api" "profile.api" "promotion.grpc" "realtimehub.api" "subscription.api" "test.api" "translation.api" "yarpapigateway" )
          echo "📦 All services: ${#ALL_SERVICES[@]}"

          git fetch --no-tags --prune origin main
          if [[ "${EVENT_NAME}" == "workflow_dispatch" ]]; then BUILD_ALL=1; else BUILD_ALL=0; fi

          if [[ -n "${BEFORE:-}" && "${BEFORE}" != "0000000000000000000000000000000000000000" ]]; then
            BASE="${BEFORE}"
          else
            if git rev-parse -q --verify HEAD~1 >/dev/null; then BASE="$(git rev-parse HEAD~1)"; else BASE="$(git merge-base origin/main HEAD)"; fi
          fi
          echo "📐 Diff base: ${BASE}"

          mapfile -t CHANGED < <(git diff --name-only --diff-filter=ACMR "${BASE}"..HEAD || true)
          echo "📝 Changed files: ${#CHANGED[@]}"

          if [[ ${#CHANGED[@]} -eq 0 ]]; then BUILD_ALL=1; fi
          if [[ $BUILD_ALL -eq 0 ]]; then
            for f in "${CHANGED[@]}"; do
              case "$f" in
                Directory.Packages.props|nuget.config|packages.lock.json|.dockerignore) BUILD_ALL=1; break;;
              esac
            done
          fi
          if [[ $BUILD_ALL -eq 1 ]]; then
            echo "🔁 BUILD_ALL=1 → build all services"
          fi

          declare -A S=(); add(){ S["$1"]=1; }
          if [[ $BUILD_ALL -eq 1 ]]; then
            for s in "${ALL_SERVICES[@]}"; do add "$s"; done
          else
            for f in "${CHANGED[@]}"; do
              case "$f" in
                Services/AIModeration/AIModeration.API/*|PsychologySupport/Services/AIModeration/AIModeration.API/*) add "aimoderation.api" ;;
                Services/Alias/Alias.API/*|PsychologySupport/Services/Alias/Alias.API/*) add "alias.api" ;;
                Services/Auth/Auth.API/*|PsychologySupport/Services/Auth/Auth.API/*) add "auth.api" ;;
                Services/ChatBox/ChatBox.API/*|PsychologySupport/Services/ChatBox/ChatBox.API/*) add "chatbox.api" ;;
                Services/DigitalGoods/DigitalGoods.API/*|PsychologySupport/Services/DigitalGoods/DigitalGoods.API/*) add "digitalgoods.api" ;;
                Services/Feed/Feed.API/*|PsychologySupport/Services/Feed/Feed.API/*) add "feed.api" ;;
                Services/Media/Media.API/*|PsychologySupport/Services/Media/Media.API/*) add "media.api" ;;
                Services/Payment/Payment.API/*|PsychologySupport/Services/Payment/Payment.API/*) add "payment.api" ;;
                Services/Post/Post.API/*|PsychologySupport/Services/Post/Post.API/*) add "post.api" ;;
                Services/Profile/Profile.API/*|PsychologySupport/Services/Profile/Profile.API/*) add "profile.api" ;;
                Services/Promotion/Promotion.Grpc/*|PsychologySupport/Services/Promotion/Promotion.Grpc/*) add "promotion.grpc" ;;
                Services/RealtimeHub/RealtimeHub.API/*|PsychologySupport/Services/RealtimeHub/RealtimeHub.API/*) add "realtimehub.api" ;;
                Services/Subscription/Subscription.API/*|PsychologySupport/Services/Subscription/Subscription.API/*) add "subscription.api" ;;
                Services/Test/Test.API/*|PsychologySupport/Services/Test/Test.API/*) add "test.api" ;;
                Services/Translation/Translation.API/*|PsychologySupport/Services/Translation/Translation.API/*) add "translation.api" ;;
                ApiGateways/YarpApiGateway/*|PsychologySupport/ApiGateways/YarpApiGateway/*) add "yarpapigateway" ;;
              esac
            done
          fi
          if [[ ${#S[@]} -eq 0 ]]; then for s in "${ALL_SERVICES[@]}"; do add "$s"; done; fi

          command -v jq >/dev/null || { sudo apt-get update -y && sudo apt-get install -y jq; }
          printf '%s\n' "${!S[@]}" | sort | jq -R -s -c 'split("\n") - [""]' > services.json
          echo "services=$(cat services.json)" >> "$GITHUB_OUTPUT"

          echo "🧩 Resolved services to build:"
          jq -r '.[]' services.json | sed 's/^/  • /'

  # 2) Build & Push (buildx bake, batch tối đa 5 service)
  build:
    needs: [pick-runner, detect-services]
    if: ${{ needs.detect-services.outputs.services != '[]' }}
    runs-on: ${{ fromJson(needs.pick-runner.outputs.runs_on) }}
    env:
      SERVICES_JSON: ${{ needs.detect-services.outputs.services }}
      COMPOSE_DIR: PsychologySupport
      COMPOSE_FILE: PsychologySupport/docker-compose.build.yml
    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4

      - name: 🧰 Setup Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: |
            env.BUILDKIT_STEP_MAX_PARALLELISM=5

      - name: 🔐 Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GIT_CONTAINER_REGISTRY_USERNAME }}
          password: ${{ secrets.GIT_CONTAINER_REGISTRY_PASSWORD }}

      # Viết PsychologySupport/.env từ secrets + override IMAGE_TAG=SHA
      - name: 📝 Write env file (Linux)
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: |
          set -euo pipefail
          : "${{ secrets.ENV_PROD }}"
          mkdir -p "${COMPOSE_DIR}"
          printf "%s\n" "${{ secrets.ENV_PROD }}" > "${COMPOSE_DIR}/.env"
          echo "IMAGE_TAG=${GITHUB_SHA}" >> "${COMPOSE_DIR}/.env"
          echo "✅ .env written (content hidden)"

      - name: 📝 Write env file (Windows)
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path $env:COMPOSE_DIR | Out-Null
          $content = @"
          ${{ secrets.ENV_PROD }}
          "@
          Set-Content -Path "$env:COMPOSE_DIR/.env" -Value $content -Encoding UTF8
          Add-Content -Path "$env:COMPOSE_DIR/.env" -Value "IMAGE_TAG=${{ github.sha }}"
          Write-Host "✅ .env written (content hidden)"

      - name: 🔎 Buildx info
        shell: bash
        run: |
          set -euo pipefail
          echo "🐳 docker version:" && docker version || true
          echo "🧱 buildx version:" && docker buildx version || true
          echo "📋 buildx builders:" && docker buildx ls || true

      # Linux: export .env → buildx bake theo batch 5
      - name: 🏗️ Build & push with buildx bake (Linux, batches of 5)
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: |
          set -euo pipefail
          export DOCKER_DEFAULT_PLATFORM=linux/amd64
          export COMPOSE_DOCKER_CLI_BUILD=1

          # 👉 Export toàn bộ biến từ .env vào environment cho buildx bake
          echo "📦 Loading env from ${COMPOSE_DIR}/.env"
          set -a
          # shellcheck disable=SC1090
          source "${COMPOSE_DIR}/.env"
          set +a
          echo "🔖 DOCKER_REGISTRY=${DOCKER_REGISTRY:-<unset>} | IMAGE_TAG=${IMAGE_TAG:-<unset>}"

          command -v jq >/dev/null || { sudo apt-get update -y && sudo apt-get install -y jq; }
          mapfile -t SVCS < <(echo "$SERVICES_JSON" | jq -r '.[]')
          N=${#SVCS[@]}
          [[ $N -eq 0 ]] && { echo "⚠️ No services to build"; exit 0; }

          BATCH_SIZE=5
          TOTAL_BATCHES=$(( (N + BATCH_SIZE - 1) / BATCH_SIZE ))
          echo "🧮 Services: $N  |  Batch size: $BATCH_SIZE  |  Total batches: $TOTAL_BATCHES"
          echo "🗂️  Service list:"; for s in "${SVCS[@]}"; do echo "  • $s"; done

          PIPE_START=$(date +%s)
          for ((i=0; i<N; i+=BATCH_SIZE)); do
            BATCH=( "${SVCS[@]:i:BATCH_SIZE}" )
            IDX=$(( i / BATCH_SIZE + 1 ))
            echo ""
            echo "⏱️  Batch ${IDX}/${TOTAL_BATCHES} → ${#BATCH[@]} targets"
            for b in "${BATCH[@]}"; do echo "   🔸 $b"; done
            BATCH_START=$(date +%s)
            docker buildx bake -f "${COMPOSE_FILE}" --push "${BATCH[@]}"
            BATCH_END=$(date +%s)
            echo "✅ Done batch ${IDX}/${TOTAL_BATCHES} in $((BATCH_END-BATCH_START))s"
          done
          PIPE_END=$(date +%s)
          echo ""
          echo "🎉 All batches completed in $((PIPE_END-PIPE_START))s"

      # Windows: export .env → buildx bake theo batch 5
      - name: 🏗️ Build & push with buildx bake (Windows, batches of 5)
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $env:DOCKER_DEFAULT_PLATFORM = "linux/amd64"
          $env:COMPOSE_DOCKER_CLI_BUILD = "1"

          # 👉 Export toàn bộ biến từ .env vào environment cho buildx bake
          Write-Host "📦 Loading env from $env:COMPOSE_DIR/.env"
          Get-Content "$env:COMPOSE_DIR/.env" | ForEach-Object {
            if ($_ -match '^\s*#' -or -not $_.Trim()) { return }
            $kv = $_ -split '=',2
            if ($kv.Length -eq 2) {
              $k = $kv[0].Trim(); $v = $kv[1].Trim()
              [System.Environment]::SetEnvironmentVariable($k, $v)
              Set-Item -Path "Env:$k" -Value $v
            }
          }
          Write-Host "🔖 DOCKER_REGISTRY=$env:DOCKER_REGISTRY | IMAGE_TAG=$env:IMAGE_TAG"

          $svcs = ($env:SERVICES_JSON | ConvertFrom-Json)
          if (-not $svcs -or $svcs.Count -eq 0) {
            Write-Host "⚠️ No services to build"
            exit 0
          }

          $batchSize = 5
          $total = [int]$svcs.Count
          $totalBatches = [int][Math]::Ceiling($total / [double]$batchSize)

          Write-Host "🧮 Services: $total  |  Batch size: $batchSize  |  Total batches: $totalBatches"
          Write-Host "🗂️  Service list:"; $svcs | ForEach-Object { Write-Host "  • $_" }

          $pipelineStart = Get-Date
          for ($i = 0; $i -lt $total; $i += $batchSize) {
            $idx = [int]($i / $batchSize) + 1
            $end = [Math]::Min($i + $batchSize - 1, $total - 1)
            $batch = if ($i -eq $end) { @($svcs[$i]) } else { $svcs[$i..$end] }

            Write-Host ""
            Write-Host "⏱️  Batch $idx/$totalBatches → $($batch.Count) targets"
            $batch | ForEach-Object { Write-Host "   🔸 $_" }

            $batchStart = Get-Date
            docker buildx bake -f "$env:COMPOSE_FILE" --push $batch
            $batchEnd = Get-Date
            $elapsed = [int]([TimeSpan]::op_Subtraction($batchEnd, $batchStart).TotalSeconds)
            Write-Host "✅ Done batch $idx/$totalBatches in ${elapsed}s"
          }

          $totalElapsed = [int]([TimeSpan]::op_Subtraction((Get-Date), $pipelineStart).TotalSeconds)
          Write-Host ""
          Write-Host "🎉 All batches completed in ${totalElapsed}s"
